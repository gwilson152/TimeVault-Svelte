# TimeVault-Svelte Code Generation Instructions

- NEVER update package.json directly for package installation. Use npm install.

## Tailwind v4 Implementation Notes
- Tailwind v4 uses a new approach to CSS layers - be aware of these changes when adding custom utility classes
- Custom component styles should be defined in the `@layer components` section with complete style definitions
- Avoid circular references within the same @layer - never @apply a custom class that's being defined in the same block
- Instead, define each class with its complete set of styles independently
- Don't extend custom component classes with @apply - duplicate the properties instead
- For table actions, implement each variant (primary, danger, etc.) as a complete standalone class
- Example correct implementation:
```css
@layer components {
  .table-action-button {
    display: inline-flex;
    align-items: center;
    padding: 0.375rem 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    border-radius: 0.375rem;
    transition-property: color, background-color;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 200ms;
  }

  .table-action-button-primary {
    display: inline-flex;
    align-items: center;
    padding: 0.375rem 0.75rem;
    font-size: 0.875rem;
    font-weight: 500;
    border-radius: 0.375rem;
    transition-property: color, background-color;
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    transition-duration: 200ms;
    background-color: rgba(59, 130, 246, 0.2);
    color: rgb(147, 197, 253);
  }

  .table-action-button-primary:hover {
    background-color: rgba(59, 130, 246, 0.3);
  }
}
```

## Development Task Management and Tracking/accounting 
- [Completed and Pending Tasks](./development-todo.md) â€” Always keep updated and timestamp each task upon completion.

## Client Management Business Rules
- Client types include: 'business', 'individual', and 'container'
- Individual clients CAN have parent clients
- Only 'business' and 'container' clients can be parent clients
- Business and container clients can both be parents and have parents
- When using the client form component, ensure these validation rules are enforced:
  1. Filter out non-business and non-container clients from available parents dropdown
  2. Handle empty string parentId values by converting to null before API calls
- These rules prevent the "Foreign key constraint violated: `clients_parentId_fkey`" error

## Style Management
- All global styles, themes, and reusable component styles should be placed in `src/lib/styles/tailwind-theme.css`
- Component-specific styles that are not reusable should remain in their respective component files
- Use Tailwind CSS utility classes when possible for component styling
- Custom component styles should be defined in the `@layer components` section of tailwind-theme.css
- Global styles and theme variables should be defined in the `@theme` section of tailwind-theme.css
- Background images and global layout styles should be defined in the base styles section of tailwind-theme.css

### Glass Effect Classes
Three glass effect utility classes are available:
1. `container-glass`: Base glass effect class with configurable padding
   - Background with proper opacity
   - Backdrop blur effect
   - Border and shadow effects
   - Hover state improvements
2. `light-glass`: Lighter variant with higher opacity background
   - Extends container-glass
   - Used for subtle glass effects
3. `card-glass`: Pre-configured card style
   - Extends container-glass
   - Fixed padding (1.5rem)
   - Rounded corners (0.5rem)
   - Specific shadow and border styles

### Implementation Guidelines
```css
@theme {
  :root {
    --color-container-glass: oklch(0.98 0.01 180 / 0.4);
    --color-light-glass: oklch(0.95 0.02 180 / 0.6);
    --blur-amount: 8px;
    --border-color: oklch(0.85 0.02 200 / 0.6);
  }
}

@layer base {
  body {
    @apply bg-gradient-to-br from-gray-900 to-gray-800;
    background-image: url('/backgrounds/bg-light-2.jpg');
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
  }
}

@layer components {
  .container-glass {
    @apply backdrop-blur-lg bg-opacity-10 border shadow-lg;
    background-color: var(--color-container-glass);
    backdrop-filter: blur(var(--blur-amount));
    border-color: var(--border-color);
    transition: background-color 0.2s ease;
  }

  .container-glass:hover {
    background-color: var(--color-light-glass);
  }

  .light-glass {
    @apply container-glass bg-opacity-5;
  }

  .card-glass {
    @apply container-glass rounded-lg p-6;
  }
}
```

## Component Organization
- All components should be exported from `src/lib/components/index.ts`
- Component imports should use the barrel file: `import { ComponentName } from '$lib/components'`
- Component types should be defined in `src/lib/types/index.ts`
- Reusable component logic should be extracted into stores or utility functions

## Glass Card Implementation
- Use the GlassCard component for creating glass-morphism effects in the UI
- Glass card styling is implemented through the `container-glass` utility class in tailwind-theme.css
- Glass effect properties:
  - Uses `var(--color-container-glass)` for background with proper opacity
  - Applies `backdrop-filter: blur(8px)` for the frosted glass effect
  - Includes subtle border and shadow effects for depth
  - Has hover state improvements for interactivity
- For variations on the glass effect, use the `light-glass` utility class or custom padding props

### GlassCard Implementation Example
```svelte
<!-- GlassCard.svelte -->
<script lang="ts">
  export let padding = 'p-6';
  export let className = '';
</script>

<div class="container-glass {padding} {className}">
  <slot />
</div>
```

## Modal Implementation
- Use the Modal component for all dialogs and popups in the application
- Modals use glass-morphism styling through the GlassCard component
- Always implement proper keyboard navigation and accessibility features
- Follow consistent layout patterns for modal content

### Modal Features
- ESC key closes the modal
- Clicking overlay (outside modal) closes the modal
- Proper ARIA attributes for accessibility
- Optional title section with consistent styling
- Optional footer section for actions
- Customizable width using standard max-width classes
- Animated entrance/exit transitions
- Glass card styling for content

### Modal Component Example
```svelte
<script lang="ts">
  import { Modal } from '$lib/components';
  
  let showModal = false;
</script>

<Modal
  open={showModal}
  title="Modal Title"
  width="max-w-2xl"
  on:close={() => showModal = false}
>
  <div class="p-6">
    <!-- Modal content -->
  </div>
  
  <svelte:fragment slot="footer">
    <div class="flex justify-end gap-3">
      <button class="form-submit" on:click={() => showModal = false}>
        Close
      </button>
    </div>
  </svelte:fragment>
</Modal>
```

### Modal Props
- `open` (boolean): Controls modal visibility
- `title` (string): Optional title shown in header
- `width` (string): Optional max-width class (default: max-w-2xl)

### Events
- `on:close`: Dispatched when modal should close (ESC or overlay click)

### Best Practices
1. Always provide a way to close the modal (close button and/or cancel action)
2. Use consistent padding for content (p-6 recommended)
3. Place primary actions in the footer slot
4. Implement proper focus management
5. Show loading states for async operations
6. Handle form submission and validation properly
7. Use appropriate max-width for content type:
   - Forms: max-w-lg
   - Confirmation dialogs: max-w-md
   - Large content/tables: max-w-2xl or max-w-4xl

### Common Modal Patterns
1. Form Modals
```svelte
<Modal title="Add Item" open={showModal} on:close={() => showModal = false}>
  <form class="form-group p-6" on:submit|preventDefault={handleSubmit}>
    <!-- Form fields -->
  </form>
  
  <svelte:fragment slot="footer">
    <div class="flex justify-end gap-3">
      <button type="button" on:click={() => showModal = false}>
        Cancel
      </button>
      <button type="submit" class="form-submit" class:loading={isSubmitting}>
        Save
      </button>
    </div>
  </svelte:fragment>
</Modal>
```

2. Confirmation Modals
```svelte
<Modal title="Confirm Delete" open={showConfirm} width="max-w-md">
  <div class="p-6">
    <p>Are you sure you want to delete this item?</p>
  </div>
  
  <svelte:fragment slot="footer">
    <div class="flex justify-end gap-3">
      <button on:click={() => showConfirm = false}>Cancel</button>
      <button 
        class="form-submit bg-red-600 hover:bg-red-700" 
        on:click={handleDelete}
      >
        Delete
      </button>
    </div>
  </svelte:fragment>
</Modal>
```

3. Loading States
```svelte
<Modal open={isLoading} width="max-w-md">
  <div class="p-6 text-center">
    <div class="animate-pulse text-gray-400">Loading...</div>
  </div>
</Modal>
```

## ActionBar Implementation
- ActionBar is implemented as a fixed navigation component at the bottom of the screen
- Uses the actionBarStore for state management of navigation items
- Navigation items include icons and tooltips using @steeze-ui/heroicons
- Styling follows glass-morphism design using container-glass utility class
- Features:
  - Responsive design with different layouts for mobile and desktop
  - Hover animations and transitions for interactive feedback
  - Tooltip display on hover (desktop) or always visible (mobile)
  - Flash animation trigger support for navigation updates

### ActionBar Store Implementation
```typescript
// actionBarStore.ts
import { writable } from 'svelte/store';
import type { Icon } from '@steeze-ui/heroicons';
import { 
  UserGroup, 
  Ticket, 
  Clock, 
  DocumentText 
} from '@steeze-ui/heroicons';

export interface Action {
  href: string;
  icon: Icon;
  tooltip: string;
  badge?: number;
}

const defaultActions: Action[] = [
  { href: '/clients', icon: UserGroup, tooltip: 'Clients' },
  { href: '/tickets', icon: Ticket, tooltip: 'Tickets' },
  { href: '/time-entries', icon: Clock, tooltip: 'Time' },
  { href: '/invoices', icon: DocumentText, tooltip: 'Invoices' }
];

function createActionBarStore() {
  const { subscribe, set, update } = writable<Action[]>(defaultActions);

  return {
    subscribe,
    setActions: (actions: Action[]) => set(actions),
    reset: () => set(defaultActions),
    updateBadge: (href: string, count: number) => {
      update(actions => actions.map(action => 
        action.href === href 
          ? { ...action, badge: count }
          : action
      ));
    }
  };
}

export const actionBarStore = createActionBarStore();
```

### ActionBar Component Example
```svelte
<!-- ActionBar.svelte -->
<script lang="ts">
  import { Icon } from '@steeze-ui/svelte-icon';
  import { actionBarStore, type Action } from '$lib/stores/actionBarStore';
  import { page } from '$app/stores';

  $: currentPath = $page.url.pathname;
</script>

<nav class="fixed bottom-0 left-0 right-0 p-4">
  <div class="container-glass mx-auto max-w-screen-xl rounded-full px-6 py-3">
    <div class="flex justify-around items-center">
      {#each $actionBarStore as action}
        <a
          href={action.href}
          class="relative p-2 rounded-full transition-colors duration-200"
          class:text-blue-500={currentPath.startsWith(action.href)}
          class:text-gray-400={!currentPath.startsWith(action.href)}
        >
          <Icon src={action.icon} class="w-6 h-6" />
          {#if action.badge}
            <span class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
              {action.badge}
            </span>
          {/if}
          <span class="sr-only">{action.tooltip}</span>
        </a>
      {/each}
    </div>
  </div>
</nav>
```

### Usage Examples
```typescript
// In a route component
import { actionBarStore } from '$lib/stores/actionBarStore';
import { UserGroup, Cog } from '@steeze-ui/heroicons';

// Update navigation for settings page
actionBarStore.setActions([
  { href: '/clients', icon: UserGroup, tooltip: 'Back to Clients' },
  { href: '/settings', icon: Cog, tooltip: 'Settings' }
]);

// Reset to default navigation when leaving
onDestroy(() => {
  actionBarStore.reset());
});
```

## Page Implementation
- All pages should be placed in the `src/routes` directory following SvelteKit conventions
- Use +page.svelte for page components and +page.server.ts for server-side logic
- Follow a consistent page structure:
  1. Page Header with title and primary actions
  2. Loading states using GlassCard
  3. Filter/Control sections when needed
  4. Main content area
  5. Modals for forms/dialogs

### Page Structure Example
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { GlassCard, Modal } from '$lib/components';
  import { Icon } from '@steeze-ui/svelte-icon';
  
  // State initialization
  let isLoading = true;
  let data = [];
  
  // Load data on mount
  onMount(async () => {
    try {
      // Load required data
      isLoading = false;
    } catch (error) {
      console.error('Failed to load:', error);
    }
  });
</script>

<div class="space-y-6">
  <!-- Page Header -->
  <GlassCard className="p-6">
    <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
      <div class="flex items-center space-x-3">
        <Icon src={PageIcon} class="w-8 h-8 text-blue-500" />
        <h1 class="text-2xl font-bold">Page Title</h1>
      </div>
      <div class="flex gap-3">
        <!-- Primary Actions -->
      </div>
    </div>
  </GlassCard>

  <!-- Loading State -->
  {#if isLoading}
    <GlassCard className="p-6">
      <div class="text-center py-12">
        <div class="text-gray-400 animate-pulse">Loading...</div>
      </div>
    </GlassCard>
  {:else}
    <!-- Optional Filters/Controls -->
    <GlassCard className="p-4">
      <div class="flex flex-col md:flex-row justify-between gap-4">
        <!-- Filter Controls -->
      </div>
    </GlassCard>

    <!-- Main Content -->
    <GlassCard className="p-0 overflow-hidden">
      <!-- Content -->
    </GlassCard>
  {/if}
</div>

<!-- Modals -->
<Modal open={showModal} on:close={() => showModal = false}>
  <!-- Modal Content -->
</Modal>
```

### Page Implementation Guidelines
- Use responsive layouts with mobile-first approach
- Implement proper loading states and error handling
- Group related controls and actions together
- Use GlassCard components for content sections
- Follow consistent spacing using space-y-6 for main sections
- Implement proper TypeScript types for all data and props
- Extract reusable logic into stores or utility functions
- Use appropriate Svelte transitions for dynamic content
- Follow ARIA best practices for accessibility

### Common Page Patterns
1. List Views
   - Use responsive grid or list layouts
   - Implement filtering and sorting controls
   - Show empty states when no data
   - Use consistent item layouts

2. Form Pages
   - Group related fields together
   - Implement proper validation
   - Show submission status and errors
   - Use Modal for edit/create forms

3. Detail Views
   - Show hierarchical information
   - Include related data sections
   - Provide edit/delete actions
   - Implement breadcrumb navigation

4. Dashboard Pages
   - Use grid layout for widgets
   - Implement data summaries
   - Show loading states for each widget
   - Include refresh mechanisms

### Billing Rate Implementation
- Billing rate overrides should only be configured on individual client pages
- Each client can have custom rate overrides for any billing rate
- Support both percentage and fixed rate adjustments
- Override management interface should use the standard form styling conventions
- Implement proper validation for rate override values
- Use proper error handling and loading states
- Follow this pattern for calculations:
  ```typescript
  const override = client.billingRateOverrides.find(o => o.baseRateId === rate.id);
  const effectiveRate = override 
    ? override.type === 'percentage' 
      ? (baseRate * override.value / 100) 
      : override.value
    : baseRate;
  ```

### Time Entry Implementation
- Time entries use `duration` (not `hours`) for tracking time spent
- The TimeEntry interface defines duration as a number representing hours
- All calculations should use the duration property
- Client is optional for time entries
- When displaying duration values:
  - Use `duration.toFixed(1)` for compact display
  - Use `formatTime(duration)` from invoiceUtils for formatted display
- Follow this pattern for calculations involving time entries and billing rates:
  ```typescript
  // Only calculate billable amount if there's a billing rate
  const amount = billingRate?.rate ? billingRate.rate * entry.duration : 0;
  
  // Only calculate cost if there's a billing rate
  const cost = billingRate?.cost ? billingRate.cost * entry.duration : 0;
  
  // Calculate profit
  const profit = amount - cost;
  ```
- Use the proper schema for form validation:
  ```typescript
  const timeEntrySchema = z.object({
    description: z.string().min(1, 'Description is required'),
    startTime: z.date(),
    endTime: z.date().nullable(),
    duration: z.number().min(0.01, 'Duration must be greater than 0'),
    date: z.date(),
    clientId: z.string().nullable(), // Client is optional
    ticketId: z.string().nullable(),
    billable: z.boolean().default(false), // Default to non-billable since client is optional
    billingRateId: z.string().nullable(),
    billed: z.boolean().optional().default(false),
    locked: z.boolean().optional().default(false),
    invoiceId: z.string().nullable(),
    billedRate: z.number().optional()
  });
  ```

### Time Entry Locking Implementation
- Time entries associated with invoices must be locked to preserve financial integrity
- Implement locking at multiple levels:
  1. UI Layer: Disable form controls and show clear visual indicators
  2. Store Layer: Prevent update/delete operations on locked entries
  3. API Layer: Return appropriate error responses (HTTP 403) for locked entries
- UI Implementation Requirements:
  - Display a visual lock indicator for locked entries
  - Disable all form fields when an entry is locked
  - Show explanatory message with link to associated invoice
  - Update button states and tooltips to indicate locked status
- Time Entry Store Implementation:
  - Check for `locked` or `billed` status before update/delete operations
  - Set both `locked: true` and `billed: true` when marking entries as billed
  - Return appropriate error messages for attempted modifications of locked entries
- API Implementation Requirements:
  - Check entry status in PUT/DELETE endpoints before allowing modifications
  - Return HTTP 403 Forbidden with descriptive error message for locked entries
  - Set `locked: true` in addition to `billed: true` when associating entries with invoices
- Locking should be triggered when:
  1. Time entries are included in an invoice
  2. The `markAsBilled` function is called on time entries
- NewTimeEntry interface includes the following locking-related fields:
  - `billed`: Indicates if the entry is associated with an invoice
  - `locked`: Prevents modification of the entry
  - `invoiceId`: References the associated invoice
  - `billedRate`: Captures the rate at time of billing for financial records

### State Management
- Use Svelte stores for shared state
- Implement proper TypeScript types for store data
- Follow loading/error/success patterns
- Cache data appropriately
- Clear/reset state when leaving pages

### Performance Considerations
- Implement proper loading states
- Use transition animations judiciously
- Optimize store subscriptions
- Implement pagination for large datasets
- Use proper error boundaries
- Cache expensive computations with $: reactive statements


# TimeVault Styling Conventions

## Form Styling

Use these consistent form styles across all forms in the application:

### Basic Form Structure
```html
<form class="form-group">
  <div class="form-field">
    <label class="form-label">Label Text</label>
    <input class="form-input" />
    <span class="form-hint">Helper text</span>
    <span class="form-error">Error message</span>
  </div>
</form>
```

### Available Classes

#### Container Classes
- `form-group`: Container for form fields with proper spacing and animations
- `form-field`: Individual form field container with proper margins

#### Input Classes
- `form-input`: Text inputs and number inputs
- `form-select`: Select dropdowns
- `form-textarea`: Multiline text areas
- `form-checkbox`, `form-radio`: Checkbox and radio inputs

#### Text Classes
- `form-label`: Input labels
- `form-hint`: Helper text below inputs
- `form-error`: Error messages (includes shake animation)

#### Button Classes
- `form-submit`: Primary submit button
- Add `.loading` class for loading state

### Animations
Forms include built-in animations:
- Slide-in on form group mount
- Shake animation for error states
- Loading state pulse animation
- Smooth transitions for hover/focus states

### Best Practices
1. Always use proper semantic HTML elements
2. Include labels for all form controls
3. Use helper text to provide additional context
4. Show validation errors inline
5. Maintain consistent spacing using the provided classes
6. Use the glass-morphism effect for form containers

### Example Usage:
```html
<form class="form-group">
  <div class="form-field">
    <label for="name" class="form-label">Name</label>
    <input 
      id="name"
      type="text"
      class="form-input"
      placeholder="Enter your name"
    />
    <span class="form-hint">First and last name</span>
  </div>
  
  <div class="form-field">
    <label for="email" class="form-label">Email</label>
    <input 
      id="email"
      type="email" 
      class="form-input"
      class:error={emailError}
    />
    {#if emailError}
      <span class="form-error">{emailError}</span>
    {/if}
  </div>

  <button type="submit" class="form-submit" class:loading={isSubmitting}>
    Submit
  </button>
</form>
```