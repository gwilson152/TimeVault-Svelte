# TimeVault-Svelte Code Generation Instructions

- NEVER update package.json directly for package installation. Use npm install.

## Svelte Runes Mode Implementation

- Use `$props()` instead of `export let` for component props in runes mode
- Example implementation:
```svelte
<script lang="ts">
  // CORRECT: Use $props() for component props in runes mode
  const {
    selectedClientId = $state(null as string | null),
    label = $state('Client'),
    placeholder = $state('Select a client')
  } = $props();

  // Local state
  let searchQuery = $state('');
  
  // Computed values
  const filteredClients = $derived(() => {
    // Computation logic here
  });
</script>
```

## Tailwind v4 Implementation Notes
- Custom component styles should be defined in the `@layer components` section with complete style definitions
- Avoid circular references within the same @layer
- Define each class with its complete set of styles independently
- Don't extend custom component classes with @apply - duplicate the properties instead

## Client Management Business Rules
- Client types include: 'business', 'individual', and 'container'
- Only 'business' and 'container' clients can be parent clients
- When using the client form component:
  1. Filter out non-business and non-container clients from available parents dropdown
  2. Handle empty string parentId values by converting to null before API calls

### Client Hierarchy Display Guidelines
- Use proper indentation to show parent-child relationships
- Add client type indicators (üè¢ Business, üìÅ Container, üë§ Individual)
- Sort clients so parents appear before their children
- Include clear helper text explaining available options

## Style Management
- Global styles should be in `src/lib/styles/tailwind-theme.css`
- Use Tailwind utility classes when possible
- Available glass effect classes:
  - `container-glass`: Base glass effect with configurable padding
  - `light-glass`: Lighter variant with higher opacity background
  - `card-glass`: Pre-configured card style with fixed padding and rounded corners

## Component Guidelines

### ClientSearch Component
- Props:
  - `selectedClientId?: string | null` - Currently selected client ID
  - `label?: string` - Label text (default: 'Client')
  - `placeholder?: string` - Placeholder text (default: 'Select a client')
  - `showSearch?: boolean` - Show search input (default: true)
  - `showIcon?: boolean` - Show client icon (default: true)
  - `className?: string` - Additional classes for container
  - `fieldClassName?: string` - Additional classes for field wrapper
  - `hint?: string` - Custom hint text
  - `restrictToClientId?: string | null` - Restrict to specific client hierarchy
  - `allowNullSelection?: boolean` - Allow no selection (default: true)

- Events:
  - `on:change` - Emits when selection changes, detail is the new client ID or null

- Implementation Notes:
  1. Use event dispatch pattern instead of bind:value for two-way binding
  2. Filter clients based on search text and hierarchy restrictions
  3. Show client type indicators (üè¢, üìÅ, üë§)
  4. Sort and indent clients to show hierarchy
  5. Include default hint text explaining client types

```svelte
<script lang="ts">
  const {
    selectedClientId = $state(null as string | null),
    label = $state('Client'),
    placeholder = $state('Select a client'),
    showSearch = $state(true),
    showIcon = $state(true),
    className = $state(''),
    fieldClassName = $state(''),
    hint = $state(''),
    restrictToClientId = $state(null as string | null),
    allowNullSelection = $state(true)
  } = $props();

  const dispatch = createEventDispatcher<{
    change: string | null;
  }>();

  function handleSelectionChange(event: Event) {
    const select = event.target as HTMLSelectElement;
    const value = select.value ? select.value : null;
    dispatch('change', value);
  }
</script>
```

### GlassCard Component
- Use for creating glass-morphism effects in the UI
- Configurable padding and class name props

### Modal Component
- Features: ESC key closes, overlay click closes, ARIA attributes, title section, footer section
- Props: `open` (boolean), `title` (string), `width` (string)
- Events: `on:close`

### Form Styling
- Use consistent form classes:
  - Container: `form-group`, `form-field`
  - Input: `form-input`, `form-select`, `form-textarea`, `form-checkbox`, `form-radio`
  - Text: `form-label`, `form-hint`, `form-error`
  - Button: `form-submit` (add `.loading` for loading state)

### Table Styling
- Use consistent table classes:
  - `data-table`: Base class for all tables
  - `data-table-header`: Header row styling 
  - `data-table-row`: Body row styling with hover effect
  - `data-table-footer`: Footer row styling for totals/summaries
  - Use `right-aligned` class for numeric columns

### ActionBar Implementation
- Fixed navigation component at the bottom of the screen
- Uses the actionBarStore for state management

## Business Logic Requirements

### Time Entry Logic
- Use `duration` (not `hours`) for tracking time spent
- Client is optional for time entries
- Display formats:
  - Use `duration.toFixed(1)` for compact display
  - Use `formatTime(duration)` from invoiceUtils for formatted display
- Locked entries (associated with invoices) cannot be modified

### Billing Rate Calculations
```typescript
const effectiveRate = override 
  ? override.type === 'percentage' 
    ? (baseRate * override.value / 100) 
    : override.value
  : baseRate;
```

## Best Practices
- Implement proper loading states and error handling
- Extract reusable logic into stores or utility functions
- Follow ARIA best practices for accessibility
- Cache expensive computations with $: reactive statements or $derived
- Use consistent page structure across the application
