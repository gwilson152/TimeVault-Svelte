# TimeVault-Svelte Code Generation Instructions

- NEVER update package.json directly for package installation. Use npm install.

## Development Task Management and Tracking/accounting 
- [Completed and Pending Tasks](./development-todo.md) â€” Always keep updated and timestamp each task upon completion.

## Client Management Business Rules
- Client types include: 'business', 'individual', and 'organization'
- Individual clients cannot be parent clients
- Individual clients cannot have parent clients
- Business and organization clients can both be parents and have parents
- When using the client form component, ensure these validation rules are enforced:
  1. Filter out individual clients from available parents dropdown
  2. Disable parent selection when client type is 'individual'
  3. Automatically clear parentId when switching client type to 'individual'
  4. Handle empty string parentId values by converting to null before API calls
- These rules prevent the "Foreign key constraint violated: `clients_parentId_fkey`" error

## Style Management
- All global styles, themes, and reusable component styles should be placed in `src/lib/styles/tailwind-theme.css`
- Component-specific styles that are not reusable should remain in their respective component files
- Use Tailwind CSS utility classes when possible for component styling
- Custom component styles should be defined in the `@layer components` section of tailwind-theme.css
- Global styles and theme variables should be defined in the `@theme` section of tailwind-theme.css
- Background images and global layout styles should be defined in the base styles section of tailwind-theme.css

### Implementation Guidelines
```css
@theme {
  :root {
    --color-container-glass: rgba(255, 255, 255, 0.1);
    --color-container-glass-hover: rgba(255, 255, 255, 0.15);
    --blur-amount: 8px;
    --border-color: rgba(255, 255, 255, 0.1);
  }
}

@layer base {
  body {
    @apply bg-gradient-to-br from-gray-900 to-gray-800;
    background-image: url('/backgrounds/bg-dark-1.jpg');
    background-size: cover;
    background-position: center;
    background-attachment: fixed;
  }
}

@layer components {
  .container-glass {
    @apply backdrop-blur-lg bg-opacity-10 border border-white/10 shadow-lg;
    background-color: var(--color-container-glass);
    backdrop-filter: blur(var(--blur-amount));
    transition: background-color 0.2s ease;
  }

  .container-glass:hover {
    background-color: var(--color-container-glass-hover);
  }

  .light-glass {
    @apply container-glass bg-opacity-5;
  }

  .card-glass {
    @apply container-glass rounded-lg p-6;
  }
}
```

## Component Organization
- All components should be exported from `src/lib/components/index.ts`
- Component imports should use the barrel file: `import { ComponentName } from '$lib/components'`
- Component types should be defined in `src/lib/types/index.ts`
- Reusable component logic should be extracted into stores or utility functions

## Glass Card Implementation
- Use the GlassCard component for creating glass-morphism effects in the UI
- Glass card styling is implemented through the `container-glass` utility class in tailwind-theme.css
- Glass effect properties:
  - Uses `var(--color-container-glass)` for background with proper opacity
  - Applies `backdrop-filter: blur(8px)` for the frosted glass effect
  - Includes subtle border and shadow effects for depth
  - Has hover state improvements for interactivity
- For variations on the glass effect, use either `light-glass` or `card-glass` utility classes as needed

### GlassCard Implementation Example
```svelte
<!-- GlassCard.svelte -->
<script lang="ts">
  let className = '';
  export { className as class };
</script>

<div class="card-glass {className}">
  <slot />
</div>
```

## ActionBar Implementation
- ActionBar is implemented as a fixed navigation component at the bottom of the screen
- Uses the actionBarStore for state management of navigation items
- Navigation items include icons and tooltips using @steeze-ui/heroicons
- Styling follows glass-morphism design using container-glass utility class
- Features:
  - Responsive design with different layouts for mobile and desktop
  - Hover animations and transitions for interactive feedback
  - Tooltip display on hover (desktop) or always visible (mobile)
  - Flash animation trigger support for navigation updates

### ActionBar Store Implementation
```typescript
// actionBarStore.ts
import { writable } from 'svelte/store';
import type { Icon } from '@steeze-ui/heroicons';
import { 
  UserGroup, 
  Ticket, 
  Clock, 
  DocumentText 
} from '@steeze-ui/heroicons';

export interface Action {
  href: string;
  icon: Icon;
  tooltip: string;
  badge?: number;
}

const defaultActions: Action[] = [
  { href: '/clients', icon: UserGroup, tooltip: 'Clients' },
  { href: '/tickets', icon: Ticket, tooltip: 'Tickets' },
  { href: '/time-entries', icon: Clock, tooltip: 'Time' },
  { href: '/invoices', icon: DocumentText, tooltip: 'Invoices' }
];

function createActionBarStore() {
  const { subscribe, set, update } = writable<Action[]>(defaultActions);

  return {
    subscribe,
    setActions: (actions: Action[]) => set(actions),
    reset: () => set(defaultActions),
    updateBadge: (href: string, count: number) => {
      update(actions => actions.map(action => 
        action.href === href 
          ? { ...action, badge: count }
          : action
      ));
    }
  };
}

export const actionBarStore = createActionBarStore();
```

### ActionBar Component Example
```svelte
<!-- ActionBar.svelte -->
<script lang="ts">
  import { Icon } from '@steeze-ui/svelte-icon';
  import { actionBarStore, type Action } from '$lib/stores/actionBarStore';
  import { page } from '$app/stores';

  $: currentPath = $page.url.pathname;
</script>

<nav class="fixed bottom-0 left-0 right-0 p-4">
  <div class="container-glass mx-auto max-w-screen-xl rounded-full px-6 py-3">
    <div class="flex justify-around items-center">
      {#each $actionBarStore as action}
        <a
          href={action.href}
          class="relative p-2 rounded-full transition-colors duration-200"
          class:text-blue-500={currentPath.startsWith(action.href)}
          class:text-gray-400={!currentPath.startsWith(action.href)}
        >
          <Icon src={action.icon} class="w-6 h-6" />
          {#if action.badge}
            <span class="absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-4 h-4 flex items-center justify-center">
              {action.badge}
            </span>
          {/if}
          <span class="sr-only">{action.tooltip}</span>
        </a>
      {/each}
    </div>
  </div>
</nav>
```

### Usage Examples
```typescript
// In a route component
import { actionBarStore } from '$lib/stores/actionBarStore';
import { UserGroup, Cog } from '@steeze-ui/heroicons';

// Update navigation for settings page
actionBarStore.setActions([
  { href: '/clients', icon: UserGroup, tooltip: 'Back to Clients' },
  { href: '/settings', icon: Cog, tooltip: 'Settings' }
]);

// Reset to default navigation when leaving
onDestroy(() => {
  actionBarStore.reset();
});
```

## Page Implementation
- All pages should be placed in the `src/routes` directory following SvelteKit conventions
- Use +page.svelte for page components and +page.server.ts for server-side logic
- Follow a consistent page structure:
  1. Page Header with title and primary actions
  2. Loading states using GlassCard
  3. Filter/Control sections when needed
  4. Main content area
  5. Modals for forms/dialogs

### Page Structure Example
```svelte
<script lang="ts">
  import { onMount } from 'svelte';
  import { GlassCard, Modal } from '$lib/components';
  import { Icon } from '@steeze-ui/svelte-icon';
  
  // State initialization
  let isLoading = true;
  let data = [];
  
  // Load data on mount
  onMount(async () => {
    try {
      // Load required data
      isLoading = false;
    } catch (error) {
      console.error('Failed to load:', error);
    }
  });
</script>

<div class="space-y-6">
  <!-- Page Header -->
  <GlassCard className="p-6">
    <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
      <div class="flex items-center space-x-3">
        <Icon src={PageIcon} class="w-8 h-8 text-blue-500" />
        <h1 class="text-2xl font-bold">Page Title</h1>
      </div>
      <div class="flex gap-3">
        <!-- Primary Actions -->
      </div>
    </div>
  </GlassCard>

  <!-- Loading State -->
  {#if isLoading}
    <GlassCard className="p-6">
      <div class="text-center py-12">
        <div class="text-gray-400 animate-pulse">Loading...</div>
      </div>
    </GlassCard>
  {:else}
    <!-- Optional Filters/Controls -->
    <GlassCard className="p-4">
      <div class="flex flex-col md:flex-row justify-between gap-4">
        <!-- Filter Controls -->
      </div>
    </GlassCard>

    <!-- Main Content -->
    <GlassCard className="p-0 overflow-hidden">
      <!-- Content -->
    </GlassCard>
  {/if}
</div>

<!-- Modals -->
<Modal open={showModal} on:close={() => showModal = false}>
  <!-- Modal Content -->
</Modal>
```

### Page Implementation Guidelines
- Use responsive layouts with mobile-first approach
- Implement proper loading states and error handling
- Group related controls and actions together
- Use GlassCard components for content sections
- Follow consistent spacing using space-y-6 for main sections
- Implement proper TypeScript types for all data and props
- Extract reusable logic into stores or utility functions
- Use appropriate Svelte transitions for dynamic content
- Follow ARIA best practices for accessibility

### Common Page Patterns
1. List Views
   - Use responsive grid or list layouts
   - Implement filtering and sorting controls
   - Show empty states when no data
   - Use consistent item layouts

2. Form Pages
   - Group related fields together
   - Implement proper validation
   - Show submission status and errors
   - Use Modal for edit/create forms

3. Detail Views
   - Show hierarchical information
   - Include related data sections
   - Provide edit/delete actions
   - Implement breadcrumb navigation

4. Dashboard Pages
   - Use grid layout for widgets
   - Implement data summaries
   - Show loading states for each widget
   - Include refresh mechanisms

### Billing Rate Implementation
- Billing rate overrides should only be configured on individual client pages
- Each client can have custom rate overrides for any billing rate
- Support both percentage and fixed rate adjustments
- Override management interface should use the standard form styling conventions
- Implement proper validation for rate override values
- Use proper error handling and loading states
- Follow this pattern for calculations:
  ```typescript
  const override = client.billingRateOverrides.find(o => o.baseRateId === rate.id);
  const effectiveRate = override 
    ? override.type === 'percentage' 
      ? (baseRate * override.value / 100) 
      : override.value
    : baseRate;
  ```

### State Management
- Use Svelte stores for shared state
- Implement proper TypeScript types for store data
- Follow loading/error/success patterns
- Cache data appropriately
- Clear/reset state when leaving pages

### Performance Considerations
- Implement proper loading states
- Use transition animations judiciously
- Optimize store subscriptions
- Implement pagination for large datasets
- Use proper error boundaries
- Cache expensive computations with $: reactive statements


# TimeVault Styling Conventions

## Form Styling

Use these consistent form styles across all forms in the application:

### Basic Form Structure
```html
<form class="form-group">
  <div class="form-field">
    <label class="form-label">Label Text</label>
    <input class="form-input" />
    <span class="form-hint">Helper text</span>
    <span class="form-error">Error message</span>
  </div>
</form>
```

### Available Classes

#### Container Classes
- `form-group`: Container for form fields with proper spacing and animations
- `form-field`: Individual form field container with proper margins

#### Input Classes
- `form-input`: Text inputs and number inputs
- `form-select`: Select dropdowns
- `form-textarea`: Multiline text areas
- `form-checkbox`, `form-radio`: Checkbox and radio inputs

#### Text Classes
- `form-label`: Input labels
- `form-hint`: Helper text below inputs
- `form-error`: Error messages (includes shake animation)

#### Button Classes
- `form-submit`: Primary submit button
- Add `.loading` class for loading state

### Animations
Forms include built-in animations:
- Slide-in on form group mount
- Shake animation for error states
- Loading state pulse animation
- Smooth transitions for hover/focus states

### Best Practices
1. Always use proper semantic HTML elements
2. Include labels for all form controls
3. Use helper text to provide additional context
4. Show validation errors inline
5. Maintain consistent spacing using the provided classes
6. Use the glass-morphism effect for form containers

### Example Usage:
```html
<form class="form-group">
  <div class="form-field">
    <label for="name" class="form-label">Name</label>
    <input 
      id="name"
      type="text"
      class="form-input"
      placeholder="Enter your name"
    />
    <span class="form-hint">First and last name</span>
  </div>
  
  <div class="form-field">
    <label for="email" class="form-label">Email</label>
    <input 
      id="email"
      type="email" 
      class="form-input"
      class:error={emailError}
    />
    {#if emailError}
      <span class="form-error">{emailError}</span>
    {/if}
  </div>

  <button type="submit" class="form-submit" class:loading={isSubmitting}>
    Submit
  </button>
</form>
```