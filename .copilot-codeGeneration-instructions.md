# TimeVault Development Guidelines

## Modal Component Implementation

### Basic Modal Usage

The Modal component in TimeVault follows a specific pattern for implementation. Here's the standard structure:

```svelte
<Modal
  open={showModal}
  title="Modal Title"
  size="lg"
  onclose={() => (showModal = false)}
>
  <div class="p-6">
    <!-- Modal content goes here -->
  </div>

  {#snippet footer()}
    <div slot="footer" class="flex justify-end gap-3">
      <button class="btn btn-secondary" onclick={() => (showModal = false)}>
        Cancel
      </button>
      <button class="btn btn-primary" onclick={handleAction}>
        Confirm
      </button>
    </div>
  {/snippet}
</Modal>
```

### Required Props

- `open`: Boolean state controlling modal visibility
- `title`: String for modal header
- `size`: Size of modal ("sm", "md", "lg", "xl")
- `onclose`: Function to handle modal closing

### Footer Implementation

Always use the snippet pattern for footers:

```svelte
{#snippet footer()}
  <div slot="footer" class="flex justify-end gap-3">
    <!-- Footer buttons -->
  </div>
{/snippet}
```

### Button Styles

- Use `btn-secondary` for Cancel/Close buttons
- Use `btn-primary` for main action buttons
- Use `btn-danger` for destructive actions

### Content Guidelines

1. Wrap content in `<div class="p-6">`
2. Use `text-gray-900` for main text
3. Use `text-sm text-gray-600` for supporting text
4. Use `rounded bg-amber-100 p-3 text-amber-800` for warning messages

### Example Implementation

```svelte
<Modal
  open={showDialog}
  title="Confirm Action"
  size="lg"
  onclose={() => (showDialog = false)}
>
  <div class="p-6">
    <p class="mb-4 text-gray-900">
      Are you sure you want to perform this action?
    </p>
    <p class="text-sm text-gray-600">
      This action cannot be undone.
    </p>
  </div>

  {#snippet footer()}
    <div slot="footer" class="flex justify-end gap-3">
      <button class="btn btn-secondary" onclick={() => (showDialog = false)}>
        Cancel
      </button>
      <button class="btn btn-primary" onclick={handleConfirm}>
        Confirm
      </button>
    </div>
  {/snippet}
</Modal>
```

### Best Practices

1. Always include a cancel/close button
2. Use clear, action-oriented button labels
3. Provide feedback for destructive actions
4. Handle loading states with disabled buttons
5. Include appropriate spacing in content area
6. Use semantic colors for different types of actions

## API and Data Fetching Conventions

### Route Structure for API Endpoints

API endpoints should follow the SvelteKit file-based routing pattern with separate endpoint files for collections and individual resources:

1. Collection endpoints (`/api/resource/+server.ts`):
   - GET: List all resources
   - POST: Create a new resource

2. Individual resource endpoints (`/api/resource/[id]/+server.ts`):
   - GET: Get resource by ID
   - PUT: Update resource by ID
   - DELETE: Delete resource by ID

### Example API Structure

```
src/routes/api/
  resource/
    +server.ts         // GET (list), POST (create)
    [id]/
      +server.ts       // GET, PUT, DELETE for individual resources
```

### API Implementation Pattern

All API endpoints should use standard SvelteKit handlers:

```typescript
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import { prisma } from '$lib/server/db';

// GET handler - retrieve resource by ID
export const GET: RequestHandler = async ({ params }) => {
  try {
    const { id } = params;
    const resource = await prisma.resource.findUnique({
      where: { id },
      include: { /* relations */ }
    });
    
    if (!resource) {
      throw error(404, 'Resource not found');
    }
    
    return json(resource);
  } catch (err) {
    // Error handling
  }
};

// PUT handler - update resource
export const PUT: RequestHandler = async ({ params, request }) => {
  // Implementation
};

// DELETE handler - delete resource
export const DELETE: RequestHandler = async ({ params }) => {
  // Implementation
};
```

### Client-Side Data Fetching

Always use the following pattern for client-side data fetching:

1. Use the stores for data access
2. Never hardcode API URLs in components
3. Use relative URLs for API endpoints (`/api/resources` not `https://example.com/api/resources`)

```typescript
// Correct approach - use store
await clientStore.load();

// Incorrect approach - direct fetch with absolute URL
const response = await fetch('https://timevault.example.com/api/clients');
```

### Error Handling

Implement proper error handling for all API calls:

```typescript
try {
  // API call
} catch (error) {
  console.error('Failed to fetch resource:', error);
  errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
}
```

## Event Handling

### Correct Event Handlers

Always use the following event handler formats:

```svelte
<!-- Correct format -->
<td class="w-10" onclick={(e) => e.stopPropagation()}>

<!-- Form submission -->
<form onsubmit={(e) => editingRate ? handleUpdateRate(e) : handleCreateRate(e)} class="space-y-4">
```

### Incorrect Event Handlers

Avoid using Svelte V4 event handlers:

```svelte
<!-- Incorrect format -->
<td class="w-10" on:click={(e) => e.stopPropagation()}>
```

WRONG:
  $: totalMinutes = Object.values(entryTotals).reduce((sum, entry) => sum + entry.minutes, 0);
  $: totalAmount = Object.values(entryTotals).reduce((sum, entry) => sum + entry.amount, 0);

Use Svelte 5 runes:
  // Computed totals using runes
  const totalMinutes = $derived(
    Object.values(entryTotals).reduce((sum, entry) => sum + entry.minutes, 0)
  );

  const totalAmount = $derived(
    Object.values(entryTotals).reduce((sum, entry) => sum + entry.amount, 0)
  );
